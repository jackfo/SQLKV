/* Generated By:JavaCC: Do not edit this line. SQLParser.java */
package com.cfs.sqlkv.compile.parse;

import com.cfs.sqlkv.catalog.types.*;
import com.cfs.sqlkv.catalog.types.DataTypeDescriptor;
import com.cfs.sqlkv.column.*;
import com.cfs.sqlkv.common.context.*;
import com.cfs.sqlkv.compile.*;
import com.cfs.sqlkv.compile.table.*;
import com.cfs.sqlkv.compile.node.*;
import com.cfs.sqlkv.compile.result.*;
import com.cfs.sqlkv.compile.name.TableName;
import com.cfs.sqlkv.common.*;
import com.cfs.sqlkv.sql.dictionary.*;
import com.cfs.sqlkv.util.*;

import java.sql.*;
import java.util.*;

public class SQLParser implements SQLParserConstants {

    private static final int NO_SET_OP = 0;
    //参数数量
    private int parameterNumber;
    //默认的参数
    private Object[] paramDefaults;
    //SQL文本
    private String statementSQLText;

    private boolean isDistinct;

    private static final int DEFAULT_STRING_COLUMN_LENGTH = 1;

    private static final int OFFSET_CLAUSE = 0;
    private static final int FETCH_FIRST_CLAUSE = OFFSET_CLAUSE + 1;
    private static final int OFFSET_CLAUSE_COUNT = FETCH_FIRST_CLAUSE + 1;

    /**
     * 如果最后一个标识符或关键字是分隔标识符
     * 用来记住是否需要做序列化处理
     */
    private boolean lastTokenDelimitedIdentifier = false;
    private boolean nextToLastTokenDelimitedIdentifier = false;
    /**
     * 获取的最后一个标识符Token
     */
    private Token lastIdentifierToken;
    /**
     * 下一个标识符Token
     */
    private Token nextToLastIdentifierToken;
    private Token thirdToLastIdentifierToken;

    private ContextManager cm;
    private CompilerContext compilerContext;

    private static final int OPTIONAL_TABLE_CLAUSES_SIZE = 3;
    private static final int OPTIONAL_TABLE_CLAUSES_TABLE_PROPERTIES = 0;

    private static final int OPTIONAL_TABLE_CLAUSES_DERIVED_RCL = 1;
    private static final int OPTIONAL_TABLE_CLAUSES_CORRELATION_NAME = 2;


    public final void setCompilerContext(CompilerContext cc) {
        this.compilerContext = cc;
        this.cm = cc.getContextManager();
    }

    private final CompilerContext getCompilerContext() {
        return compilerContext;
    }

    //初始化Statement
    private void initStatement(String statementSQLText, Object[] paramDefaults) {
        parameterNumber = 0;
        this.statementSQLText = statementSQLText;
        this.paramDefaults = paramDefaults;
        //TODO:尚未实现SQL优化器
    }

    private boolean remainingPredicateFollows() {
        boolean retval = false;

        switch (getToken(1).kind) {
            case EQUALS_OPERATOR:
            case NOT_EQUALS_OPERATOR:
            case NOT_EQUALS_OPERATOR2: // !=
            case LESS_THAN_OPERATOR:
            case GREATER_THAN_OPERATOR:
            case LESS_THAN_OR_EQUALS_OPERATOR:
            case GREATER_THAN_OR_EQUALS_OPERATOR:
            case IN:
            case IS:
            case LIKE:
            case BETWEEN:
                retval = true;
                break;

            case NOT:
                switch (getToken(2).kind) {
                    case IN:
                    case LIKE:
                    case BETWEEN:
                        retval = true;
                }
                break;
        }

        return retval;
    }

    private final ContextManager getContextManager() {
        return cm;
    }

    /**
     * 根据表名获取Java数据类型
     */
    private DataTypeDescriptor getJavaClassDataTypeDescriptor(TableName typeName) {
        return new DataTypeDescriptor(TypeId.getUserDefinedTypeId(typeName.getSchemaName(), typeName.getTableName(), null), true);
    }

    boolean commonDatatypeName(boolean checkFollowingToken) {
        return commonDatatypeName(1, checkFollowingToken);
    }

    private void setUpAndLinkParameters() {

    }

    public NumericConstantNode getNumericNode(String num, boolean intsOnly) {
        ContextManager cm = getContextManager();
        return new NumericConstantNode(TypeId.getBuiltInTypeId(Types.INTEGER), Integer.valueOf(num), cm);
    }

    private StatementNode getDeleteNode(FromTable fromTable,
                                        TableName tableName,
                                        ValueNode whereClause) {
        FromList fromList = new FromList(getContextManager());
        fromList.addFromTable(fromTable);

        SelectNode resultSet = new SelectNode(null,
                fromList, /* FROM list */
                whereClause, /* WHERE clause */
                getContextManager());

        StatementNode retval = new DeleteNode(tableName, resultSet, getContextManager());

        setUpAndLinkParameters();

        return retval;
    }

    private StatementNode getUpdateNode(FromTable fromTable, TableName tableName, ResultColumnList setClause, ValueNode whereClause) {
        FromList fromList = new FromList(getContextManager());
        fromList.addFromTable(fromTable);
        SelectNode resultSet = new SelectNode(setClause,
                fromList, /* FROM list */
                whereClause, /* WHERE clause */

                getContextManager());

        StatementNode retval = new UpdateNode(tableName, resultSet, getContextManager());

        setUpAndLinkParameters();

        return retval;
    }

    /**
     * 检测是否跟随着行值构造集合
     * 要求:第一个Token是(
     */
    private boolean rowValueConstructorListFollows() {
        int nesting;
        boolean returnValue = false;
        if (getToken(1).kind == LEFT_PAREN) {
            nesting = 1;
            for (int i = 2; true; i++) {
                int tokKind = getToken(i).kind;
                if (i == 2 && (tokKind == NULL || tokKind == _DEFAULT)) {
                    returnValue = true;
                    break;
                }
                if (nesting == 1 && tokKind == COMMA) {
                    returnValue = true;
                    break;
                }
                if (tokKind == EOF) {
                    break;
                }
                if (tokKind == LEFT_PAREN) {
                    nesting++;
                } else if (tokKind == RIGHT_PAREN) {
                    nesting--;
                }
                if (nesting == 0) {
                    break;
                }
            }
        }
        return returnValue;
    }


    boolean commonDatatypeName(int start, boolean checkFollowingToken) {
        boolean retval = false;

        switch (getToken(start).kind) {
            case CHARACTER:
            case CHAR:
            case VARCHAR:
            case NVARCHAR:
            case NCHAR:
            case BIT:
            case NUMERIC:
            case DECIMAL:
            case DEC:
            case INTEGER:
            case INT:
            case SMALLINT:
            case BIGINT:
            case FLOAT:
            case REAL:
            case DATE:
            case TIME:
            case TIMESTAMP:
            case BOOLEAN:
            case DOUBLE:
            case BLOB:
            case CLOB:
            case NCLOB:
            case BINARY: // LARGE OBJECT
            case XML:
                retval = true;
                break;

            case LONG:
                if (checkFollowingToken == true) {
                    switch (getToken(start + 1).kind) {
                        case VARCHAR:
                        case NVARCHAR:
                        case BINARY:
                        case VARBINARY:
                        case BIT:
                            retval = true;
                            break;
                    }
                    break;
                } else {
                    retval = true;
                    break;
                }

            case NATIONAL:
                if (checkFollowingToken == true) {
                    switch (getToken(start + 1).kind) {
                        case CHAR:
                        case CHARACTER:
                            retval = true;
                            break;
                    }
                    break;
                } else {
                    retval = true;
                    break;
                }
        }

        return retval;
    }

    final public StatementNode statement(String statementSQLText, Object[] paramDefaults) throws ParseException {
        StatementNode statementNode;
        initStatement(statementSQLText, paramDefaults);
        statementNode = StatementPart(null);
        jj_consume_token(0);
        //statementNode.setBeginOffset(0);
        //statementNode.setEndOffset(statementSQLText.length() - 1);
        {
            if (true) return statementNode;
        }
        throw new Error("Missing return statement in function");
    }

    final public StatementNode searchCondition(String sql) throws ParseException {
        {
            if (true) return null;
        }
        throw new Error("Missing return statement in function");
    }

    /**
     * 第一个实现查询语句preparableSQLDataStatement
     */
    final public StatementNode StatementPart(Token[] tokenHolder) throws ParseException {
        StatementNode statementNode;
        if (tokenHolder != null) {
            tokenHolder[0] = getToken(1);
        }
        switch (jj_nt.kind) {
            case CREATE:
                statementNode = createStatements();
                break;
            case DELETE:
            case INSERT:
            case SELECT:
            case UPDATE:
            case VALUES:
                //实现查询语句preparableSQLDataStatement
                statementNode = preparableSQLDataStatement();
                break;
            default:
                jj_la1[0] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if (true) return statementNode;
        }
        throw new Error("Missing return statement in function");
    }

    final public StatementNode preparableSQLDataStatement() throws ParseException {
        StatementNode dmlStatement = null;
        switch (jj_nt.kind) {
            case SELECT:
            case VALUES:
                dmlStatement = preparableSelectStatement(true);
            {
                if (true) return dmlStatement;
            }
            break;
            case INSERT:
                dmlStatement = insertStatement();
            {
                if (true) return dmlStatement;
            }
            break;
            case UPDATE:
                dmlStatement = preparableUpdateStatement();
            {
                if (true) return dmlStatement;
            }
            break;
            case DELETE:
                dmlStatement = preparableDeleteStatement();
            {
                if (true) return dmlStatement;
            }
            break;
            default:
                jj_la1[1] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    final public StatementNode preparableDeleteStatement() throws ParseException {
        StatementNode qtn;
        jj_consume_token(DELETE);
        qtn = deleteBody();
        {
            if (true) return qtn;
        }
        throw new Error("Missing return statement in function");
    }

    final public StatementNode deleteBody() throws ParseException {
        JavaToSQLValueNode javaToSQLNode = null;
        String correlationName = null;
        TableName tableName = null;
        ValueNode whereClause = null;
        FromTable fromTable = null;
        QueryTreeNode retval;
        Properties targetProperties = null;
        Token whereToken = null;
        jj_consume_token(FROM);
        tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
        whereToken = jj_consume_token(WHERE);
        whereClause = whereClause(whereToken);
        if (fromTable == null)
            fromTable = new FromBaseTable(tableName,
                    correlationName,
                    FromBaseTable.DELETE,
                    null,
                    getContextManager());
        {
            if (true) return getDeleteNode(fromTable, tableName, whereClause);
        }
        throw new Error("Missing return statement in function");
    }

    final public StatementNode insertStatement() throws ParseException {
        StatementNode insertNode;
        QueryTreeNode targetTable;
        jj_consume_token(INSERT);
        jj_consume_token(INTO);
        targetTable = targetTable();
        insertNode = insertColumnsAndSource(targetTable);
        setUpAndLinkParameters();

        {
            if (true) return insertNode;
        }
        throw new Error("Missing return statement in function");
    }

    final public StatementNode insertColumnsAndSource(QueryTreeNode targetTable) throws ParseException {
        Properties targetProperties = null;
        ResultSetNode queryExpression = null;
        ResultColumnList columnList = null;
        ValueNode[] offsetClauses = new ValueNode[OFFSET_CLAUSE_COUNT];
        boolean hasJDBClimitClause = false;
        if (getToken(1).kind == LEFT_PAREN) {
            jj_consume_token(LEFT_PAREN);
            columnList = insertColumnList();
            jj_consume_token(RIGHT_PAREN);
        } else {
            ;
        }
        queryExpression = queryExpression(null, NO_SET_OP);
        {
            if (true) return new InsertNode(
                    targetTable,
                    columnList,
                    queryExpression,
                    null,
                    targetProperties,
                    null,
                    offsetClauses[OFFSET_CLAUSE],
                    offsetClauses[FETCH_FIRST_CLAUSE],
                    hasJDBClimitClause,
                    getContextManager());
        }
        throw new Error("Missing return statement in function");
    }

    final public ResultColumnList insertColumnList() throws ParseException {
        ResultColumnList columnList = new ResultColumnList(getContextManager());
        columnQualifiedNameList(columnList);
        {
            if (true) return columnList;
        }
        throw new Error("Missing return statement in function");
    }

    final public void columnQualifiedNameList(ResultColumnList columnList) throws ParseException {
        columnQualifiedNameItem(columnList);
        label_1:
        while (true) {
            switch (jj_nt.kind) {
                case COMMA:
                    ;
                    break;
                default:
                    jj_la1[2] = jj_gen;
                    break label_1;
            }
            jj_consume_token(COMMA);
            columnQualifiedNameItem(columnList);
        }
    }

    final public void columnQualifiedNameItem(ResultColumnList columnList) throws ParseException {
        ColumnReference columnRef;
        ResultColumn resultColumn;
    /*
     		SQL92 only wants identifiers here (column names)
     		but JBuilder expects table.column, so we allow the
     		general form.
     	 */
        columnRef = columnReference();
        /*
         ** Store the column names for the result columns in the
         ** result column list.  We don't know yet what valueNodes
         ** should be hooked up to each result column, so set that
         ** to null for now.
         */
        resultColumn = new ResultColumn(columnRef,
                null,
                getContextManager());
        columnList.addResultColumn(resultColumn);
    }

    final public ColumnReference columnReference() throws ParseException {
        String firstName;
        String secondName = null;
        String thirdName = null;
        String columnName = null;
        String tableName = null;
        String schemaName = null;
        TableName tabName = null;
        firstName = identifier(Limits.MAX_IDENTIFIER_LENGTH, false);
        if (getToken(1).kind == PERIOD &&
                getToken(3).kind != LEFT_PAREN) {
            jj_consume_token(PERIOD);
            secondName = identifier(Limits.MAX_IDENTIFIER_LENGTH, false);
            if (getToken(1).kind == PERIOD &&
                    getToken(3).kind != LEFT_PAREN) {
                jj_consume_token(PERIOD);
                thirdName = identifier(Limits.MAX_IDENTIFIER_LENGTH, false);
            } else {
                ;
            }
        } else {
            ;
        }
        // Figure out what each name stands for
        if (thirdName == null) {
            if (secondName == null) {
                // Only one name, must be column name
                columnName = firstName;
            } else {
                // Two names: table.column
                tableName = firstName;
                columnName = secondName;
            }
        } else {
            // Three names: schema.table.column
            schemaName = firstName;
            tableName = secondName;
            columnName = thirdName;
        }

        IdUtil.checkIdentifierLengthLimit(columnName, Limits.MAX_IDENTIFIER_LENGTH);
        if (schemaName != null)
            IdUtil.checkIdentifierLengthLimit(schemaName, Limits.MAX_IDENTIFIER_LENGTH);
        if (tableName != null)
            IdUtil.checkIdentifierLengthLimit(tableName, Limits.MAX_IDENTIFIER_LENGTH);

        if (tableName != null) {
            tabName = new TableName(
                    schemaName,
                    tableName,
                    (thirdName == null
                            ? nextToLastIdentifierToken
                            : thirdToLastIdentifierToken).beginOffset,
                    nextToLastIdentifierToken.endOffset,
                    getContextManager());
        }

        {
            if (true) return new ColumnReference(
                    columnName,
                    tabName,
                    Integer.valueOf(lastIdentifierToken.beginOffset),
                    Integer.valueOf(lastIdentifierToken.endOffset),
                    getContextManager());
        }
        throw new Error("Missing return statement in function");
    }

    final public CursorNode preparableSelectStatement(boolean checkParams) throws ParseException {
        ResultSetNode queryExpression;
        ArrayList<String> updateColumns = new ArrayList<String>();
        CursorNode retval;
        queryExpression = queryExpression(null, NO_SET_OP);
        retval = new CursorNode("SELECT", queryExpression, getContextManager());
        {
            if (true) return retval;
        }
        throw new Error("Missing return statement in function");
    }

    final public ResultSetNode queryExpression(ResultSetNode leftSide, int operatorType) throws ParseException {
        ResultSetNode term;
        term = nonJoinQueryTerm(leftSide, operatorType);
        {
            if (true) return term;
        }
        throw new Error("Missing return statement in function");
    }

    final public ResultSetNode nonJoinQueryTerm(ResultSetNode leftSide, int operatorType) throws ParseException {
        ResultSetNode term;
        term = nonJoinQueryPrimary();
        {
            if (true) return term;
        }
        throw new Error("Missing return statement in function");
    }

    final public ResultSetNode nonJoinQueryPrimary() throws ParseException {
        ResultSetNode primary;
        primary = simpleTable();
        {
            if (true) return primary;
        }
        throw new Error("Missing return statement in function");
    }

    final public ResultSetNode simpleTable() throws ParseException {
        ResultSetNode resultSetNode;
        switch (jj_nt.kind) {
            case SELECT:
                resultSetNode = querySpecification();
            {
                if (true) return resultSetNode;
            }
            break;
            case VALUES:
                resultSetNode = tableValueConstructor();
            {
                if (true) return resultSetNode;
            }
            break;
            default:
                jj_la1[3] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    /**
     * 详细查询
     */
    final public ResultSetNode querySpecification() throws ParseException {
        ResultColumnList selectList;
        SelectNode selectNode;
        boolean isDistinct = false;
        jj_consume_token(SELECT);
        selectList = selectList();
        selectNode = tableExpression(selectList);
        {
            if (true) return selectNode;
        }
        throw new Error("Missing return statement in function");
    }

    final public SelectNode tableExpression(ResultColumnList selectList) throws ParseException {
        SelectNode selectNode;
        FromList fromList;
        ValueNode whereClause = null;
        Token whereToken;
        fromList = fromClause();
        switch (jj_nt.kind) {
            case WHERE:
                whereToken = jj_consume_token(WHERE);
                whereClause = whereClause(whereToken);
                break;
            default:
                jj_la1[4] = jj_gen;
                ;
        }
        selectNode = new SelectNode(selectList, fromList, whereClause, getContextManager());
        {
            if (true) return selectNode;
        }
        throw new Error("Missing return statement in function");
    }

    final public ValueNode whereClause(Token beginToken) throws ParseException {
        ValueNode value;
        Token endToken;
        value = valueExpression();
        endToken = getToken(0);

        value.setBeginOffset(beginToken.endOffset + 1);
        value.setEndOffset(endToken.endOffset);

        {
            if (true) return value;
        }
        throw new Error("Missing return statement in function");
    }

    final public boolean setQuantifier() throws ParseException {
        jj_consume_token(DISTINCT);
        {
            if (true) return false;
        }
        throw new Error("Missing return statement in function");
    }

    final public ResultColumnList selectList() throws ParseException {
        ResultColumn allResultColumn;
        ResultColumnList resultColumns = new ResultColumnList(getContextManager());
        switch (jj_nt.kind) {
            case ASTERISK:
                jj_consume_token(ASTERISK);
                allResultColumn = new AllResultColumn(null, getContextManager());
                resultColumns.addResultColumn(allResultColumn);
            {
                if (true) return resultColumns;
            }
            break;
            default:
                jj_la1[5] = jj_gen;
                selectColumnList(resultColumns);
            {
                if (true) return resultColumns;
            }
        }
        throw new Error("Missing return statement in function");
    }

    /**
     * 首先在selectSublist中消费当前Token
     * 之后如果匹配到,则消费<COMMA>之后继续消费一个列
     * 这样最后将所有的列明都进行了消费
     */
    final public void selectColumnList(ResultColumnList resultColumns) throws ParseException {
        selectSublist(resultColumns);
        label_2:
        while (true) {
            switch (jj_nt.kind) {
                case COMMA:
                    ;
                    break;
                default:
                    jj_la1[6] = jj_gen;
                    break label_2;
            }
            jj_consume_token(COMMA);
            selectSublist(resultColumns);
        }
    }

    final public void selectSublist(ResultColumnList resultColumns) throws ParseException {
        /**定义结果列*/
        ResultColumn resultColumn;
        ResultColumn allResultColumn;
        TableName tableName;
        if (getToken(2).kind == PERIOD && (getToken(3).kind == ASTERISK || (getToken(4).kind == PERIOD && getToken(5).kind == ASTERISK))) {
            tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
            jj_consume_token(PERIOD);
            jj_consume_token(ASTERISK);
            allResultColumn = new AllResultColumn(tableName, getContextManager());
            resultColumns.addResultColumn(allResultColumn);
        } else {
            resultColumn = derivedColumn(resultColumns);
            resultColumns.addResultColumn(resultColumn);
        }
    }

    final public ResultColumn derivedColumn(ResultColumnList resultColumns) throws ParseException {
        ValueNode columnExpression;
        String columnName = null;
        columnExpression = valueExpression();
        {
            if (true) return new ResultColumn(columnName, columnExpression, getContextManager());
        }
        throw new Error("Missing return statement in function");
    }

    /**
     * 获取表名
     */
    final public TableName qualifiedName(int id_length_limit) throws ParseException {
        String schemaName = null;
        String qualifiedId;
        String firstName = null;
        String secondName = null;
        Token firstNameToken = null;
        //去获取标识符的第一个名字
        firstName = identifier(Limits.MAX_IDENTIFIER_LENGTH, false);
        if (getToken(1).kind == PERIOD && getToken(2).kind != ASTERISK) {
            jj_consume_token(PERIOD);
            secondName = identifier(Limits.MAX_IDENTIFIER_LENGTH, false);
        } else {
            ;
        }
        if (secondName == null) {
            //如果不是.则获取相应firstName为列名
            qualifiedId = firstName;
            firstNameToken = lastIdentifierToken;
        } else {
            schemaName = firstName;
            qualifiedId = secondName;
            firstNameToken = nextToLastIdentifierToken;
        }
        {
            if (true)
                return new TableName(schemaName, qualifiedId, firstNameToken.beginOffset, lastIdentifierToken.endOffset, getContextManager());
        }
        throw new Error("Missing return statement in function");
    }

    final public String identifier(int id_length_limit, boolean checkLength) throws ParseException {
        String id;
        id = internalIdentifier(id_length_limit, checkLength);
        {
            if (true) return id;
        }
        throw new Error("Missing return statement in function");
    }

    /**
     * 遇到标识符Token之后，将当前Token记录为最后一个Token
     * 在这里是记录倒数三个Token
     */
    final public String internalIdentifier(int id_length_limit, boolean checkLength) throws ParseException {
        String str;
        Token tok;
        tok = jj_consume_token(IDENTIFIER);
        //将标识符转化为大写
        str = StringUtil.SQLToUpperCase(tok.image);
        nextToLastTokenDelimitedIdentifier = lastTokenDelimitedIdentifier;
        lastTokenDelimitedIdentifier = false;
        thirdToLastIdentifierToken = nextToLastIdentifierToken;
        nextToLastIdentifierToken = lastIdentifierToken;
        lastIdentifierToken = tok;
        {
            if (true) return str;
        }
        throw new Error("Missing return statement in function");
    }

    final public FromList fromClause() throws ParseException {
        FromList fromList = new FromList(getContextManager());

        int tokKind;
        Token beginToken;
        Token endToken;
        jj_consume_token(FROM);
        beginToken = getToken(1);
        dummyTableReferenceRule(fromList);
        endToken = getToken(0);
        fromList.setBeginOffset(beginToken.beginOffset);
        fromList.setEndOffset(endToken.endOffset);
        {
            if (true) return fromList;
        }
        throw new Error("Missing return statement in function");
    }

    final public void dummyTableReferenceRule(FromList fromList) throws ParseException {
        FromTable tableReference;
        if (getToken(1).kind == TABLE &&
                getToken(2).kind == LEFT_PAREN &&
                (
                        getToken(3).kind == SELECT ||
                                getToken(3).kind == VALUES
                )) {
            jj_consume_token(TABLE);
            tableReference = tableReferenceTypes(false);
            fromList.addFromTable(tableReference);
        } else {
            switch (jj_nt.kind) {
                case IDENTIFIER:
                    tableReference = tableReferenceTypes(false);
                    fromList.addFromTable(tableReference);
                    break;
                default:
                    jj_la1[7] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
    }

    /**
     * 值表达式 目前实现不存在任何表达式
     */
    final public ValueNode valueExpression() throws ParseException {
        ValueNode leftOperand;
        leftOperand = orExpression(null);
        label_3:
        while (true) {
            switch (jj_nt.kind) {
                case OR:
                    ;
                    break;
                default:
                    jj_la1[8] = jj_gen;
                    break label_3;
            }
            jj_consume_token(OR);
            leftOperand = orExpression(leftOperand);
        }
        {
            if (true) return leftOperand;
        }
        throw new Error("Missing return statement in function");
    }

    final public ValueNode orExpression(ValueNode farLeftOperand) throws ParseException {
        ValueNode leftOperand;
        leftOperand = andExpression(null);
        label_4:
        while (true) {
            switch (jj_nt.kind) {
                case AND:
                    ;
                    break;
                default:
                    jj_la1[9] = jj_gen;
                    break label_4;
            }
            jj_consume_token(AND);
            leftOperand = andExpression(leftOperand);
        }
        if (farLeftOperand == null) {
            {
                if (true) return leftOperand;
            }
        } else {
            {
                if (true) return null;
            }
        }
        throw new Error("Missing return statement in function");
    }

    //TODO:待实现
    final public ValueNode andExpression(ValueNode farLeftOperand) throws ParseException {
        ValueNode test = null;
        test = isSearchCondition();
        {
            if (true) return test;
        }
        throw new Error("Missing return statement in function");
    }

    final public ValueNode isSearchCondition() throws ParseException {
        ValueNode booleanPrimary;
        booleanPrimary = booleanPrimary();
        {
            if (true) return booleanPrimary;
        }
        throw new Error("Missing return statement in function");
    }

    final public ValueNode booleanPrimary() throws ParseException {
        ValueNode primary;
        ValueNode searchCondition;
        primary = predicate();
        {
            if (true) return primary;
        }
        throw new Error("Missing return statement in function");
    }

    final public ValueNode predicate() throws ParseException {
        ValueNode value;
        value = additiveExpression(null, 0);
        label_5:
        while (true) {
            if (remainingPredicateFollows()) {
                ;
            } else {
                break label_5;
            }
            value = remainingPredicate(value);
        }
        {
            if (true) return value;
        }
        throw new Error("Missing return statement in function");
    }

    final public ValueNode remainingPredicate(ValueNode value) throws ParseException {
        Token tok = null;
        value = remainingNonNegatablePredicate(value);
        {
            if (true) return value;
        }
        throw new Error("Missing return statement in function");
    }

    final public ValueNode remainingNonNegatablePredicate(ValueNode leftOperand) throws ParseException {
        int operator;
        String javaClassName;
        Token tok = null;
        ValueNode tree = null;
        ValueNode likePattern;
        ValueNode betweenLeft;
        ValueNode betweenRight;
        operator = compOp();
        leftOperand = additiveExpression(leftOperand, operator);
        {
            if (true) return leftOperand;
        }
        throw new Error("Missing return statement in function");
    }

    final public int compOp() throws ParseException {
        switch (jj_nt.kind) {
            case EQUALS_OPERATOR:
                jj_consume_token(EQUALS_OPERATOR);
            {
                if (true) return BinaryOperatorNode.EQ;
            }
            break;
            case NOT_EQUALS_OPERATOR:
                jj_consume_token(NOT_EQUALS_OPERATOR);
            {
                if (true) return BinaryOperatorNode.NE;
            }
            break;
            case NOT_EQUALS_OPERATOR2:
                jj_consume_token(NOT_EQUALS_OPERATOR2);
            {
                if (true) return BinaryOperatorNode.NE;
            }
            break;
            case LESS_THAN_OPERATOR:
                jj_consume_token(LESS_THAN_OPERATOR);
            {
                if (true) return BinaryOperatorNode.LT;
            }
            break;
            case GREATER_THAN_OPERATOR:
                jj_consume_token(GREATER_THAN_OPERATOR);
            {
                if (true) return BinaryOperatorNode.GT;
            }
            break;
            case LESS_THAN_OR_EQUALS_OPERATOR:
                jj_consume_token(LESS_THAN_OR_EQUALS_OPERATOR);
            {
                if (true) return BinaryOperatorNode.LE;
            }
            break;
            case GREATER_THAN_OR_EQUALS_OPERATOR:
                jj_consume_token(GREATER_THAN_OR_EQUALS_OPERATOR);
            {
                if (true) return BinaryOperatorNode.GE;
            }
            break;
            default:
                jj_la1[10] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    final public ValueNode additiveExpression(ValueNode farLeftOperand, int compOp) throws ParseException {
        ValueNode leftOperand;
        int operator;
        int kind;
        leftOperand = primaryExpression();
        if (farLeftOperand == null) {
            if (true) return leftOperand;
        }
        switch (compOp) {
            case BinaryOperatorNode.EQ:
                kind = BinaryRelationalOperatorNode.K_EQUALS;
                break;

            case BinaryOperatorNode.NE:
                kind = BinaryRelationalOperatorNode.K_NOT_EQUALS;
                break;

            case BinaryOperatorNode.LT:
                kind = BinaryRelationalOperatorNode.K_LESS_THAN;
                break;

            case BinaryOperatorNode.GT:
                kind = BinaryRelationalOperatorNode.K_GREATER_THAN;
                break;

            case BinaryOperatorNode.LE:
                kind = BinaryRelationalOperatorNode.K_LESS_EQUALS;
                break;

            case BinaryOperatorNode.GE:
                kind = BinaryRelationalOperatorNode.K_GREATER_EQUALS;
                break;

            default:
                kind = -1;
                break;
        }
        {
            if (true) return new BinaryRelationalOperatorNode(
                    kind,
                    farLeftOperand,
                    leftOperand,
                    getContextManager());
        }
        throw new Error("Missing return statement in function");
    }

    final public ValueNode primaryExpression() throws ParseException {
        ValueNode value = null;
        value = primary();
        {
            if (true) return value;
        }
        throw new Error("Missing return statement in function");
    }

    final public ValueNode primary() throws ParseException {
        ValueNode value;
        value = valueExpressionPrimary();
        {
            if (true) return value;
        }
        throw new Error("Missing return statement in function");
    }

    final public ValueNode valueExpressionPrimary() throws ParseException {
        ValueNode value;
        int tokKind;
        switch (jj_nt.kind) {
            case PLUS_SIGN:
            case MINUS_SIGN:
            case EXACT_NUMERIC:
            case APPROXIMATE_NUMERIC:
                value = valueSpecification();
            {
                if (true) return value;
            }
            break;
            case IDENTIFIER:
                value = columnReference();
            {
                if (true) return value;
            }
            break;
            default:
                jj_la1[11] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    final public FromTable tableReferenceTypes(boolean nestedInParens) throws ParseException {
        FromTable tableReference;
        tableReference = tableReference(nestedInParens);
        {
            if (true) return tableReference;
        }
        throw new Error("Missing return statement in function");
    }

    final public FromTable tableReference(boolean nestedInParens) throws ParseException {
        FromTable fromTable;
        TableOperatorNode joinTable = null;
        fromTable = tableFactor();
        {
            if (true) return joinTable == null ? fromTable : joinTable;
        }
        throw new Error("Missing return statement in function");
    }

    final public FromTable tableFactor() throws ParseException {
        JavaToSQLValueNode javaToSQLNode = null;
        TableName tableName;
        String correlationName = null;
        ResultColumnList derivedRCL = null;
        FromTable fromTable;
        FromTable tableReference;
        Object[] optionalTableClauses = new Object[OPTIONAL_TABLE_CLAUSES_SIZE];
        Properties tableProperties = null;
        SubqueryNode derivedTable;
        /* identifier() used to be correlationName() */
        tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
        fromTable = new FromBaseTable(
                tableName,
                (String) optionalTableClauses[
                        OPTIONAL_TABLE_CLAUSES_CORRELATION_NAME],
                (ResultColumnList) optionalTableClauses[
                        OPTIONAL_TABLE_CLAUSES_DERIVED_RCL],
                (Properties) optionalTableClauses[
                        OPTIONAL_TABLE_CLAUSES_TABLE_PROPERTIES],
                getContextManager());
        {
            if (true) return fromTable;
        }
        throw new Error("Missing return statement in function");
    }

    final public JavaToSQLValueNode vtiTableConstruct() throws ParseException {
        MethodCallNode invocationNode = null;
        TableName vtiTableName;
        jj_consume_token(TABLE);
        jj_consume_token(LEFT_PAREN);
        vtiTableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
        jj_consume_token(RIGHT_PAREN);
        {
            if (true) return new JavaToSQLValueNode(invocationNode, getContextManager());
        }
        throw new Error("Missing return statement in function");
    }

    final public StatementNode createStatements() throws ParseException {
        StatementNode statementNode;
        Token beginToken;
        int tokKind;
        beginToken = jj_consume_token(CREATE);
        statementNode = tableDefinition();
        {
            if (true) return statementNode;
        }
        throw new Error("Missing return statement in function");
    }

    final public StatementNode tableDefinition() throws ParseException {
        char lockGranularity = TableDescriptor.DEFAULT_LOCK_GRANULARITY;
        Properties properties = null;
        TableName tableName;
        TableElementList tableElementList;
        ResultColumnList resultColumns = null;
        ResultSetNode queryExpression;
        boolean withData = true;
        jj_consume_token(TABLE);
        tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
        if (getToken(1).kind == LEFT_PAREN
                && getToken(3).kind != COMMA
                && getToken(3).kind != RIGHT_PAREN) {

        } else {
            jj_consume_token(-1);
            throw new ParseException();
        }
        tableElementList = tableElementList();
        {
            if (true) return new CreateTableNode(
                    tableName,
                    tableElementList,
                    properties,
                    lockGranularity,
                    getContextManager());
        }
        throw new Error("Missing return statement in function");
    }

    final public TableElementList tableElementList() throws ParseException {
        TableElementList tableElementList = new TableElementList(getContextManager());
        jj_consume_token(LEFT_PAREN);
        tableElement(tableElementList);
        label_6:
        while (true) {
            switch (jj_nt.kind) {
                case COMMA:
                    ;
                    break;
                default:
                    jj_la1[12] = jj_gen;
                    break label_6;
            }
            jj_consume_token(COMMA);
            tableElement(tableElementList);
        }
        jj_consume_token(RIGHT_PAREN);
        {
            if (true) return tableElementList;
        }
        throw new Error("Missing return statement in function");
    }

    final public void tableElement(TableElementList tableElementList) throws ParseException {
        TableElementNode tableElement;
        tableElement = columnDefinition(tableElementList);
        tableElementList.addTableElement(tableElement);
    }

    final public TableElementNode columnDefinition(TableElementList tableElementList) throws ParseException {
        DataTypeDescriptor[] typeDescriptor = new DataTypeDescriptor[1];
        ValueNode defaultNode = null;
        String columnName;
        long[] autoIncrementInfo = new long[5];
        columnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true);
        if (jj_2_1(1)) {
            typeDescriptor[0] = dataTypeDDL();
        } else {
            ;
        }
        {
            if (true)
                return new ColumnDefinitionNode(columnName, defaultNode, typeDescriptor[0], autoIncrementInfo, getContextManager());
        }
        throw new Error("Missing return statement in function");
    }

    final public DataTypeDescriptor dataTypeDDL() throws ParseException {
        DataTypeDescriptor typeDescriptor;
        if (commonDatatypeName(false)) {
            typeDescriptor = dataTypeCommon();
            {
                if (true) return typeDescriptor;
            }
        } else if (getToken(1).kind != GENERATED) {
            typeDescriptor = javaType(new TableName[1]);
            {
                if (true) return typeDescriptor;
            }
        } else {
            jj_consume_token(-1);
            throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    final public DataTypeDescriptor dataTypeCommon() throws ParseException {
        DataTypeDescriptor typeDescriptor;
        boolean checkCS = false;
        switch (jj_nt.kind) {
            case VARCHAR:
                typeDescriptor = characterStringType();
                break;
            case INT:
            case INTEGER:
                typeDescriptor = numericType();
                break;
            default:
                jj_la1[13] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if (true) return typeDescriptor;
        }
        throw new Error("Missing return statement in function");
    }

    final public DataTypeDescriptor characterStringType() throws ParseException {
        int length = DEFAULT_STRING_COLUMN_LENGTH;
        Token varyingToken = null;
        int type;
        jj_consume_token(VARCHAR);
        length = charLength();
        type = Types.VARCHAR;
        DataTypeDescriptor charDTD = DataTypeDescriptor.getBuiltInDataTypeDescriptor(type, length);
        {
            if (true) return charDTD;
        }
        throw new Error("Missing return statement in function");
    }

    final public int charLength() throws ParseException {
        int length;
        jj_consume_token(LEFT_PAREN);
        length = length();
        jj_consume_token(RIGHT_PAREN);
        {
            if (true) return length;
        }
        throw new Error("Missing return statement in function");
    }

    final public int length() throws ParseException {
        Token tok;
        int retval;
        tok = jj_consume_token(EXACT_NUMERIC);
        try {
            retval = Integer.parseInt(tok.image);

            if (retval > 0) {
                if (true) return retval;
            }
        } catch (NumberFormatException nfe) {
        }
        {
            if (true) throw new RuntimeException(String.format("invalid cloumn length:: %s", tok.image));
        }
        throw new Error("Missing return statement in function");
    }

    final public DataTypeDescriptor javaType(TableName[] udtName) throws ParseException {
        TableName typeName;
        typeName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
        udtName[0] = typeName;
        {
            if (true) return getJavaClassDataTypeDescriptor(typeName);
        }
        throw new Error("Missing return statement in function");
    }

    final public DataTypeDescriptor numericType() throws ParseException {
        DataTypeDescriptor typeDescriptor;
        typeDescriptor = exactNumericType();
        {
            if (true) return typeDescriptor;
        }
        throw new Error("Missing return statement in function");
    }

    final public DataTypeDescriptor exactNumericType() throws ParseException {
        int precision = TypeCompiler.DEFAULT_DECIMAL_PRECISION;
        int scale = TypeCompiler.DEFAULT_DECIMAL_SCALE;
        int type = Types.DECIMAL;
        String typeStr = "DECIMAL";
        int maxWidth;
        DataTypeDescriptor dtd = null;
        dtd = exactIntegerType();
        {
            if (true) return dtd;
        }
        throw new Error("Missing return statement in function");
    }

    final public DataTypeDescriptor exactIntegerType() throws ParseException {
        switch (jj_nt.kind) {
            case INTEGER:
                jj_consume_token(INTEGER);
                break;
            case INT:
                jj_consume_token(INT);
                break;
            default:
                jj_la1[14] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if (true) return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.INTEGER);
        }
        throw new Error("Missing return statement in function");
    }

    final public ValueNode defaultAndConstraints(DataTypeDescriptor[] typeDescriptor,
                                                 TableElementList tableElementList,
                                                 String columnName,
                                                 long[] autoIncrementInfo) throws ParseException {
        ValueNode defaultNode = null;
        {
            if (true) return defaultNode;
        }
        throw new Error("Missing return statement in function");
    }

    final public QueryTreeNode targetTable() throws ParseException {
        JavaToSQLValueNode javaToSQLNode = null;
        String correlationName = null;
        TableName tableName;
        tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
        {
            if (true) return tableName;
        }
        throw new Error("Missing return statement in function");
    }

    final public ResultSetNode tableValueConstructor() throws ParseException {
        ResultSetNode resultSetNode;
        jj_consume_token(VALUES);
        resultSetNode = tableValueConstructorList();
        {
            if (true) return resultSetNode;
        }
        throw new Error("Missing return statement in function");
    }

    final public ResultSetNode tableValueConstructorList() throws ParseException {
        ResultSetNode resultSetNode;
        resultSetNode = rowValueConstructor(null);
        label_7:
        while (true) {
            switch (jj_nt.kind) {
                case COMMA:
                    ;
                    break;
                default:
                    jj_la1[15] = jj_gen;
                    break label_7;
            }
            jj_consume_token(COMMA);
            resultSetNode = rowValueConstructor(resultSetNode);
        }
        {
            if (true) return resultSetNode;
        }
        throw new Error("Missing return statement in function");
    }

    final public ResultSetNode rowValueConstructor(ResultSetNode leftRSN) throws ParseException {
        ResultColumnList resultColumns = new ResultColumnList(getContextManager());
        ResultSetNode newRSN;
        jj_consume_token(LEFT_PAREN);
        rowValueConstructorList(resultColumns);
        jj_consume_token(RIGHT_PAREN);
        newRSN = new RowResultSetNode(resultColumns, null, getContextManager());
        {
            if (true) return newRSN;
        }
        throw new Error("Missing return statement in function");
    }

    final public void rowValueConstructorList(ResultColumnList resultColumns) throws ParseException {
        rowValueConstructorElement(resultColumns);
        label_8:
        while (true) {
            switch (jj_nt.kind) {
                case COMMA:
                    ;
                    break;
                default:
                    jj_la1[16] = jj_gen;
                    break label_8;
            }
            jj_consume_token(COMMA);
            rowValueConstructorElement(resultColumns);
        }
    }

    final public void rowValueConstructorElement(ResultColumnList resultColumns) throws ParseException {
        ValueNode value;
        value = valueExpression();
        resultColumns.addResultColumn(new ResultColumn((String) null,
                value,
                getContextManager()));
    }

    final public ValueNode literal() throws ParseException {
        String sign = "";
        ValueNode constantNode;
        switch (jj_nt.kind) {
            case PLUS_SIGN:
            case MINUS_SIGN:
                sign = sign();
                break;
            default:
                jj_la1[17] = jj_gen;
                ;
        }
        constantNode = numericLiteral(sign);
        {
            if (true) return constantNode;
        }
        throw new Error("Missing return statement in function");
    }

    final public String sign() throws ParseException {
        Token s;
        switch (jj_nt.kind) {
            case PLUS_SIGN:
                s = jj_consume_token(PLUS_SIGN);
            {
                if (true) return s.image;
            }
            break;
            case MINUS_SIGN:
                s = jj_consume_token(MINUS_SIGN);
            {
                if (true) return s.image;
            }
            break;
            default:
                jj_la1[18] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    final public ValueNode valueSpecification() throws ParseException {
        ValueNode value;
        value = literal();
        {
            if (true) return value;
        }
        throw new Error("Missing return statement in function");
    }

    final public ValueNode numericLiteral(String sign) throws ParseException {
        Token tok;
        switch (jj_nt.kind) {
            case EXACT_NUMERIC:
                tok = jj_consume_token(EXACT_NUMERIC);
                String num = tok.image;

                if (sign.equals("-")) {
                    num = sign.concat(num);
                }

            {
                if (true) return getNumericNode(num, false);
            }
            break;
            case APPROXIMATE_NUMERIC:
                tok = jj_consume_token(APPROXIMATE_NUMERIC);
                StringBuffer doubleImage;
                String doubleString;
                int ePosn, dotPosn; // Position of letter e and '.' in value
                Double doubleValue;

                doubleImage = new StringBuffer(sign);
                doubleImage.append(tok.image);
                doubleString = doubleImage.toString();
                doubleValue = Double.valueOf(doubleString);
            {
                if (true) return new NumericConstantNode(
                        TypeId.getBuiltInTypeId(Types.DOUBLE),
                        doubleValue,
                        getContextManager());
            }
            break;
            default:
                jj_la1[19] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    final public StatementNode preparableUpdateStatement() throws ParseException {
        StatementNode qtn;
        jj_consume_token(UPDATE);
        qtn = updateBody();
        {
            if (true) return qtn;
        }
        throw new Error("Missing return statement in function");
    }

    final public StatementNode updateBody() throws ParseException {
        ResultColumnList columnList;
        String correlationName = null;
        JavaToSQLValueNode javaToSQLNode = null;
        TableName tableName = null;
        ValueNode whereClause = null;
        FromTable fromTable = null;
        Properties targetProperties = null;
        Token whereToken = null;
        tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH);
        jj_consume_token(SET);
        columnList = setClauseList();
        switch (jj_nt.kind) {
            case WHERE:
                whereToken = jj_consume_token(WHERE);
                whereClause = whereClause(whereToken);
                break;
            default:
                jj_la1[20] = jj_gen;
                ;
        }
        fromTable = new FromBaseTable(tableName,
                correlationName,
                FromBaseTable.UPDATE,
                null,
                getContextManager());
        {
            if (true) return getUpdateNode(fromTable, tableName, columnList, whereClause);
        }
        throw new Error("Missing return statement in function");
    }

    final public ResultColumnList setClauseList() throws ParseException {
        ResultColumnList columnList = new ResultColumnList(getContextManager());
        setClause(columnList);
        label_9:
        while (true) {
            switch (jj_nt.kind) {
                case COMMA:
                    ;
                    break;
                default:
                    jj_la1[21] = jj_gen;
                    break label_9;
            }
            jj_consume_token(COMMA);
            setClause(columnList);
        }
        {
            if (true) return columnList;
        }
        throw new Error("Missing return statement in function");
    }

    final public void setClause(ResultColumnList columnList) throws ParseException {
        ResultColumn resultColumn;
        ColumnReference columnName;
        ValueNode valueNode;
        columnName = columnReference();
        jj_consume_token(EQUALS_OPERATOR);
        valueNode = updateSource(columnName.getColumnName());
        resultColumn = new ResultColumn(columnName,
                valueNode,
                getContextManager());
        columnList.addResultColumn(resultColumn);
    }

    final public ValueNode updateSource(String columnName) throws ParseException {
        ValueNode valueNode;
        valueNode = valueExpression();
        {
            if (true) return valueNode;
        }
        throw new Error("Missing return statement in function");
    }

    final private boolean jj_2_1(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_1();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(0, xla);
        }
    }

    final private boolean jj_3R_12() {
        if (jj_3R_14()) return true;
        return false;
    }

    final private boolean jj_3R_22() {
        if (jj_scan_token(IDENTIFIER)) return true;
        return false;
    }

    final private boolean jj_3R_17() {
        if (jj_3R_20()) return true;
        return false;
    }

    final private boolean jj_3R_10() {
        Token xsp;
        xsp = jj_scanpos;
        lookingAhead = true;
        jj_semLA = commonDatatypeName(false);
        lookingAhead = false;
        if (!jj_semLA || jj_3R_11()) {
            jj_scanpos = xsp;
            lookingAhead = true;
            jj_semLA = getToken(1).kind != GENERATED;
            lookingAhead = false;
            if (!jj_semLA || jj_3R_12()) return true;
        }
        return false;
    }

    final private boolean jj_3R_11() {
        if (jj_3R_13()) return true;
        return false;
    }

    final private boolean jj_3R_15() {
        if (jj_3R_18()) return true;
        return false;
    }

    final private boolean jj_3R_13() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_15()) {
            jj_scanpos = xsp;
            if (jj_3R_16()) return true;
        }
        return false;
    }

    final private boolean jj_3R_14() {
        if (jj_3R_17()) return true;
        return false;
    }

    final private boolean jj_3_1() {
        if (jj_3R_10()) return true;
        return false;
    }

    final private boolean jj_3R_23() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_scan_token(108)) {
            jj_scanpos = xsp;
            if (jj_scan_token(107)) return true;
        }
        return false;
    }

    final private boolean jj_3R_16() {
        if (jj_3R_19()) return true;
        return false;
    }

    final private boolean jj_3R_18() {
        if (jj_scan_token(VARCHAR)) return true;
        return false;
    }

    final private boolean jj_3R_21() {
        if (jj_3R_23()) return true;
        return false;
    }

    final private boolean jj_3R_19() {
        if (jj_3R_21()) return true;
        return false;
    }

    final private boolean jj_3R_20() {
        if (jj_3R_22()) return true;
        return false;
    }

    public SQLParserTokenManager token_source;
    public Token token, jj_nt;
    private Token jj_scanpos, jj_lastpos;
    private int jj_la;
    public boolean lookingAhead = false;
    private boolean jj_semLA;
    private int jj_gen;
    final private int[] jj_la1 = new int[22];
    static private int[] jj_la1_0;
    static private int[] jj_la1_1;
    static private int[] jj_la1_2;
    static private int[] jj_la1_3;
    static private int[] jj_la1_4;
    static private int[] jj_la1_5;
    static private int[] jj_la1_6;
    static private int[] jj_la1_7;
    static private int[] jj_la1_8;
    static private int[] jj_la1_9;
    static private int[] jj_la1_10;
    static private int[] jj_la1_11;
    static private int[] jj_la1_12;
    static private int[] jj_la1_13;

    static {
        jj_la1_0();
        jj_la1_1();
        jj_la1_2();
        jj_la1_3();
        jj_la1_4();
        jj_la1_5();
        jj_la1_6();
        jj_la1_7();
        jj_la1_8();
        jj_la1_9();
        jj_la1_10();
        jj_la1_11();
        jj_la1_12();
        jj_la1_13();
    }

    private static void jj_la1_0() {
        jj_la1_0 = new int[]{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x200, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,};
    }

    private static void jj_la1_1() {
        jj_la1_1 = new int[]{0x40004000, 0x40000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,};
    }

    private static void jj_la1_2() {
        jj_la1_2 = new int[]{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,};
    }

    private static void jj_la1_3() {
        jj_la1_3 = new int[]{0x400, 0x400, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1800, 0x1800, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,};
    }

    private static void jj_la1_4() {
        jj_la1_4 = new int[]{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x800, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,};
    }

    private static void jj_la1_5() {
        jj_la1_5 = new int[]{0x20, 0x20, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,};
    }

    private static void jj_la1_6() {
        jj_la1_6 = new int[]{0x84, 0x84, 0x0, 0x80, 0x2000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x200, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2000, 0x0,};
    }

    private static void jj_la1_7() {
        jj_la1_7 = new int[]{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,};
    }

    private static void jj_la1_8() {
        jj_la1_8 = new int[]{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,};
    }

    private static void jj_la1_9() {
        jj_la1_9 = new int[]{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,};
    }

    private static void jj_la1_10() {
        jj_la1_10 = new int[]{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,};
    }

    private static void jj_la1_11() {
        jj_la1_11 = new int[]{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,};
    }

    private static void jj_la1_12() {
        jj_la1_12 = new int[]{0x0, 0x0, 0x4000, 0x0, 0x0, 0x800, 0x4000, 0x0, 0x0, 0x0, 0xfe00000, 0xa000, 0x4000, 0x0, 0x0, 0x4000, 0x4000, 0xa000, 0xa000, 0x0, 0x0, 0x4000,};
    }

    private static void jj_la1_13() {
        jj_la1_13 = new int[]{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x10810, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10800, 0x0, 0x0,};
    }

    final private JJCalls[] jj_2_rtns = new JJCalls[1];
    private boolean jj_rescan = false;
    private int jj_gc = 0;

    public SQLParser(CharStream stream) {
        token_source = new SQLParserTokenManager(stream);
        token = new Token();
        token.next = jj_nt = token_source.getNextToken();
        jj_gen = 0;
        for (int i = 0; i < 22; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    public void ReInit(CharStream stream) {
        token_source.ReInit(stream);
        token = new Token();
        token.next = jj_nt = token_source.getNextToken();
        jj_gen = 0;
        for (int i = 0; i < 22; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    public SQLParser(SQLParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        token.next = jj_nt = token_source.getNextToken();
        jj_gen = 0;
        for (int i = 0; i < 22; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    public void ReInit(SQLParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        token.next = jj_nt = token_source.getNextToken();
        jj_gen = 0;
        for (int i = 0; i < 22; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    final private Token jj_consume_token(int kind) throws ParseException {
        Token oldToken = token;
        if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
        else jj_nt = jj_nt.next = token_source.getNextToken();
        if (token.kind == kind) {
            jj_gen++;
            if (++jj_gc > 100) {
                jj_gc = 0;
                for (int i = 0; i < jj_2_rtns.length; i++) {
                    JJCalls c = jj_2_rtns[i];
                    while (c != null) {
                        if (c.gen < jj_gen) c.first = null;
                        c = c.next;
                    }
                }
            }
            return token;
        }
        jj_nt = token;
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }

    static private final class LookaheadSuccess extends java.lang.Error {
    }

    final private LookaheadSuccess jj_ls = new LookaheadSuccess();

    final private boolean jj_scan_token(int kind) {
        if (jj_scanpos == jj_lastpos) {
            jj_la--;
            if (jj_scanpos.next == null) {
                jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
            } else {
                jj_lastpos = jj_scanpos = jj_scanpos.next;
            }
        } else {
            jj_scanpos = jj_scanpos.next;
        }
        if (jj_rescan) {
            int i = 0;
            Token tok = token;
            while (tok != null && tok != jj_scanpos) {
                i++;
                tok = tok.next;
            }
            if (tok != null) jj_add_error_token(kind, i);
        }
        if (jj_scanpos.kind != kind) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
        return false;
    }

    final public Token getNextToken() {
        if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
        else jj_nt = jj_nt.next = token_source.getNextToken();
        jj_gen++;
        return token;
    }

    final public Token getToken(int index) {
        Token t = lookingAhead ? jj_scanpos : token;
        for (int i = 0; i < index; i++) {
            if (t.next != null) t = t.next;
            else t = t.next = token_source.getNextToken();
        }
        return t;
    }

    private java.util.Vector<int[]> jj_expentries = new java.util.Vector<int[]>();
    private int[] jj_expentry;
    private int jj_kind = -1;
    private int[] jj_lasttokens = new int[100];
    private int jj_endpos;

    private void jj_add_error_token(int kind, int pos) {
        if (pos >= 100) return;
        if (pos == jj_endpos + 1) {
            jj_lasttokens[jj_endpos++] = kind;
        } else if (jj_endpos != 0) {
            jj_expentry = new int[jj_endpos];
            for (int i = 0; i < jj_endpos; i++) {
                jj_expentry[i] = jj_lasttokens[i];
            }
            boolean exists = false;
            for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements(); ) {
                int[] oldentry = (int[]) (e.nextElement());
                if (oldentry.length == jj_expentry.length) {
                    exists = true;
                    for (int i = 0; i < jj_expentry.length; i++) {
                        if (oldentry[i] != jj_expentry[i]) {
                            exists = false;
                            break;
                        }
                    }
                    if (exists) break;
                }
            }
            if (!exists) jj_expentries.addElement(jj_expentry);
            if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
        }
    }

    public ParseException generateParseException() {
        jj_expentries.removeAllElements();
        boolean[] la1tokens = new boolean[445];
        for (int i = 0; i < 445; i++) {
            la1tokens[i] = false;
        }
        if (jj_kind >= 0) {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 22; i++) {
            if (jj_la1[i] == jj_gen) {
                for (int j = 0; j < 32; j++) {
                    if ((jj_la1_0[i] & (1 << j)) != 0) {
                        la1tokens[j] = true;
                    }
                    if ((jj_la1_1[i] & (1 << j)) != 0) {
                        la1tokens[32 + j] = true;
                    }
                    if ((jj_la1_2[i] & (1 << j)) != 0) {
                        la1tokens[64 + j] = true;
                    }
                    if ((jj_la1_3[i] & (1 << j)) != 0) {
                        la1tokens[96 + j] = true;
                    }
                    if ((jj_la1_4[i] & (1 << j)) != 0) {
                        la1tokens[128 + j] = true;
                    }
                    if ((jj_la1_5[i] & (1 << j)) != 0) {
                        la1tokens[160 + j] = true;
                    }
                    if ((jj_la1_6[i] & (1 << j)) != 0) {
                        la1tokens[192 + j] = true;
                    }
                    if ((jj_la1_7[i] & (1 << j)) != 0) {
                        la1tokens[224 + j] = true;
                    }
                    if ((jj_la1_8[i] & (1 << j)) != 0) {
                        la1tokens[256 + j] = true;
                    }
                    if ((jj_la1_9[i] & (1 << j)) != 0) {
                        la1tokens[288 + j] = true;
                    }
                    if ((jj_la1_10[i] & (1 << j)) != 0) {
                        la1tokens[320 + j] = true;
                    }
                    if ((jj_la1_11[i] & (1 << j)) != 0) {
                        la1tokens[352 + j] = true;
                    }
                    if ((jj_la1_12[i] & (1 << j)) != 0) {
                        la1tokens[384 + j] = true;
                    }
                    if ((jj_la1_13[i] & (1 << j)) != 0) {
                        la1tokens[416 + j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 445; i++) {
            if (la1tokens[i]) {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.addElement(jj_expentry);
            }
        }
        jj_endpos = 0;
        jj_rescan_token();
        jj_add_error_token(0, 0);
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++) {
            exptokseq[i] = (int[]) jj_expentries.elementAt(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    final public void enable_tracing() {
    }

    final public void disable_tracing() {
    }

    final private void jj_rescan_token() {
        jj_rescan = true;
        for (int i = 0; i < 1; i++) {
            try {
                JJCalls p = jj_2_rtns[i];
                do {
                    if (p.gen > jj_gen) {
                        jj_la = p.arg;
                        jj_lastpos = jj_scanpos = p.first;
                        switch (i) {
                            case 0:
                                jj_3_1();
                                break;
                        }
                    }
                    p = p.next;
                } while (p != null);
            } catch (LookaheadSuccess ls) {
            }
        }
        jj_rescan = false;
    }

    final private void jj_save(int index, int xla) {
        JJCalls p = jj_2_rtns[index];
        while (p.gen > jj_gen) {
            if (p.next == null) {
                p = p.next = new JJCalls();
                break;
            }
            p = p.next;
        }
        p.gen = jj_gen + xla - jj_la;
        p.first = token;
        p.arg = xla;
    }

    static final class JJCalls {
        int gen;
        Token first;
        int arg;
        JJCalls next;
    }

}
